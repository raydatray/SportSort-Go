// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: registrations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRegistration = `-- name: CreateRegistration :one
INSERT INTO registrations (user_id, course_offering_id, registration_date, price_paid)
VALUES ($1, $2, $3, $4) RETURNING user_id, course_offering_id, registration_date, price_paid
`

type CreateRegistrationParams struct {
	UserID           int64
	CourseOfferingID int64
	RegistrationDate pgtype.Timestamptz
	PricePaid        pgtype.Numeric
}

// Creates a new registration
func (q *Queries) CreateRegistration(ctx context.Context, arg CreateRegistrationParams) (Registration, error) {
	row := q.db.QueryRow(ctx, createRegistration,
		arg.UserID,
		arg.CourseOfferingID,
		arg.RegistrationDate,
		arg.PricePaid,
	)
	var i Registration
	err := row.Scan(
		&i.UserID,
		&i.CourseOfferingID,
		&i.RegistrationDate,
		&i.PricePaid,
	)
	return i, err
}

const deleteRegistration = `-- name: DeleteRegistration :exec
DELETE FROM registrations WHERE user_id = $1 AND course_offering_id = $2
`

type DeleteRegistrationParams struct {
	UserID           int64
	CourseOfferingID int64
}

// Deletes a registration
func (q *Queries) DeleteRegistration(ctx context.Context, arg DeleteRegistrationParams) error {
	_, err := q.db.Exec(ctx, deleteRegistration, arg.UserID, arg.CourseOfferingID)
	return err
}

const getRegistration = `-- name: GetRegistration :one
SELECT user_id, course_offering_id, registration_date, price_paid FROM registrations WHERE user_id = $1 AND course_offering_id = $2
`

type GetRegistrationParams struct {
	UserID           int64
	CourseOfferingID int64
}

// Retrieves a registration by user ID and course offering ID
func (q *Queries) GetRegistration(ctx context.Context, arg GetRegistrationParams) (Registration, error) {
	row := q.db.QueryRow(ctx, getRegistration, arg.UserID, arg.CourseOfferingID)
	var i Registration
	err := row.Scan(
		&i.UserID,
		&i.CourseOfferingID,
		&i.RegistrationDate,
		&i.PricePaid,
	)
	return i, err
}

const listCourseRegistrations = `-- name: ListCourseRegistrations :many
SELECT user_id, course_offering_id, registration_date, price_paid FROM registrations WHERE course_offering_id = $1
`

// Lists all registratiosn for a course
func (q *Queries) ListCourseRegistrations(ctx context.Context, courseOfferingID int64) ([]Registration, error) {
	rows, err := q.db.Query(ctx, listCourseRegistrations, courseOfferingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Registration
	for rows.Next() {
		var i Registration
		if err := rows.Scan(
			&i.UserID,
			&i.CourseOfferingID,
			&i.RegistrationDate,
			&i.PricePaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRegistrations = `-- name: ListUserRegistrations :many
SELECT user_id, course_offering_id, registration_date, price_paid FROM registrations WHERE user_id = $1
`

// Lists all registrations for a user
func (q *Queries) ListUserRegistrations(ctx context.Context, userID int64) ([]Registration, error) {
	rows, err := q.db.Query(ctx, listUserRegistrations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Registration
	for rows.Next() {
		var i Registration
		if err := rows.Scan(
			&i.UserID,
			&i.CourseOfferingID,
			&i.RegistrationDate,
			&i.PricePaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRegistration = `-- name: UpdateRegistration :one
UPDATE registrations SET registration_date = $3, price_paid = $4
WHERE user_id = $1 AND course_offering_id = $2 RETURNING user_id, course_offering_id, registration_date, price_paid
`

type UpdateRegistrationParams struct {
	UserID           int64
	CourseOfferingID int64
	RegistrationDate pgtype.Timestamptz
	PricePaid        pgtype.Numeric
}

// Updates a registration's information
func (q *Queries) UpdateRegistration(ctx context.Context, arg UpdateRegistrationParams) (Registration, error) {
	row := q.db.QueryRow(ctx, updateRegistration,
		arg.UserID,
		arg.CourseOfferingID,
		arg.RegistrationDate,
		arg.PricePaid,
	)
	var i Registration
	err := row.Scan(
		&i.UserID,
		&i.CourseOfferingID,
		&i.RegistrationDate,
		&i.PricePaid,
	)
	return i, err
}
